<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <script src="//d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js"></script>
    <script src="https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js"></script>
    <div id="graph" style="text-align: center;"></div>
    <script>



        function scopedMethod(x) {
            return `${x}[label="$scope.${x}()"];`
        }
        function scoped(x) {
            return `${x}[label="$scope.${x}"];`
        }
        function htmlTag(x) {
            return `${x.id}[label="${x.name}${subline(x.loc)}"];`
        }
        function subline(loc) {
            let start = loc.start.line;
            let end = loc.end.line;
            let locString = start == end ? start : `${start}--${end}`;
            return `\nh: ${locString}`;
        }
        function reads({ name, reads }) {
            return !reads ? [] : reads.map(r => `${r}-> ${name};`)
        }
        function writes({ name, writes }) {
            return !writes ? [] : writes.map(r => `${name} -> ${r};`)
        }
        function calls({ name, calls }) {
            return !writes ? [] : calls.map(r => `${name} -> ${r};`)
        }
        function binding({ source, target, isEventBinding }) {
            if (isEventBinding)
                //TODO not so nice semantically
                return `${source} -> ${target}[style=solids];`
            else
                return `${source} -> ${target};`
        }
        function initMethod(calledInInit) {
            let initID = "INIT"
            let calledDot = calledInInit.map(methodName => `${initID} -> ${methodName};`)
            initDefinitionDot = [`${initID}[fillcolor=lightgrey,style=filled];`]
            return initDefinitionDot.concat(calledDot)
        }

        fetch("./data.json")
            .then(response => {
                return response.json();
            })
            .then(data => {

                //todo only for 1 file currently
                data = data[0]

                let scopedVarsDot = data.boundVariables.map(scoped).join("\n")
                let scopedMethodsDot = data.boundMethods.map(scopedMethod).join("\n")
                let htmlTagsDot = data.tagsInfo.map(htmlTag).join("\n")

                let boundMethodsWithInfo = data.boundMethods.map(
                    methodName => data.methods.find(m => m.name == methodName))
                let called = boundMethodsWithInfo.map(x => x.calls).flat().map(calledName =>
                    data.methods.find(m => m.name == calledName)
                )


                let boundMethodsWithInfoAndCalled = boundMethodsWithInfo.concat(called)
                let methodReadsDot = boundMethodsWithInfoAndCalled.map(reads).flat().join("\n")
                let methodWritesDot = boundMethodsWithInfoAndCalled.map(writes).flat().join("\n")
                let methodCallsDot = boundMethodsWithInfoAndCalled.map(calls).flat().join("\n")

                let bindingsDot = data.bindings.map(binding).join("\n")
                console.log(bindingsDot)
                //TODO how to handle call depth ? a(b) b(c) etc
                //NOTE should be handled by doing depth 1, right? is a graph

                let initDot = initMethod(data.calledInInit).join("\n")
                d3.select("#graph").graphviz()
                    .renderDot(
                        `digraph graphname {
                            forcelabels=true;
                            node[shape=box];
                            //rankdir="LR";
                            edge [style=dashed,arrowhead=empty];
                            
                            nodesep=0.6;
                            ${bindingsDot}
                            subgraph cluster_0 {
                                ${scopedVarsDot}
                                ${scopedMethodsDot}
                              
                            }
                            ${initDot}
                            subgraph cluster_1 {
                                ${htmlTagsDot}
                            }
                            ${methodReadsDot}
                            ${methodWritesDot}
                            ${methodCallsDot} 
                        }`
                    );
            })
    </script>